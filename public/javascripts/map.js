// Generated by CoffeeScript 1.3.3
var Map,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Map = (function() {

  Map.prototype.width = 30;

  Map.prototype.height = 20;

  function Map() {
    this.getUnvisitedNeighbourNodes = __bind(this.getUnvisitedNeighbourNodes, this);

    this.getCellsBetween = __bind(this.getCellsBetween, this);

    this.connectMazeNodes = __bind(this.connectMazeNodes, this);

    this.getMazeNodes = __bind(this.getMazeNodes, this);

    this.forEachCellInLine = __bind(this.forEachCellInLine, this);

    this.makePassable = __bind(this.makePassable, this);

    this.makeImpassable = __bind(this.makeImpassable, this);

    this.getCorners = __bind(this.getCorners, this);

    this.eachCell = __bind(this.eachCell, this);

    this.generateMazeMap = __bind(this.generateMazeMap, this);

    this.generateCrissCrossMap = __bind(this.generateCrissCrossMap, this);

    this.generateRoughTerrainMap = __bind(this.generateRoughTerrainMap, this);

    this.initCells = __bind(this.initCells, this);

    this.getCell = __bind(this.getCell, this);

    this.constrain = __bind(this.constrain, this);

    this.getRect = __bind(this.getRect, this);

    this.generate = __bind(this.generate, this);
    this.objects = [];
  }

  Map.prototype.generate = function(options) {
    if (options == null) {
      options = {};
    }
    this.initCells();
    return this.generateMazeMap();
  };

  Map.prototype.getRect = function() {
    return new Rect({
      left: 0,
      top: 0,
      width: this.width,
      height: this.height
    });
  };

  Map.prototype.constrain = function(coordinate, max) {
    return Math.max(0, Math.min(max, Math.floor(coordinate)));
  };

  Map.prototype.getCell = function(x, y) {
    return this.cells[this.constrain(x, this.width - 1)][this.constrain(y, this.height - 1)];
  };

  Map.prototype.initCells = function() {
    var column, x, y, _i, _ref, _results;
    this.cells = [];
    _results = [];
    for (x = _i = 0, _ref = this.width; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
      this.cells[x] = column = new Array(this.height);
      _results.push((function() {
        var _j, _ref1, _results1;
        _results1 = [];
        for (y = _j = 0, _ref1 = this.height; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
          _results1.push(column[y] = new Cell(x, y));
        }
        return _results1;
      }).call(this));
    }
    return _results;
  };

  Map.prototype.generateRoughTerrainMap = function() {
    var x, y, _i, _ref, _results;
    _results = [];
    for (x = _i = 0, _ref = this.width; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
      _results.push((function() {
        var _j, _ref1, _results1;
        _results1 = [];
        for (y = _j = 0, _ref1 = this.height; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
          if ((x % 4 === 3 || y % 4 === 3) && Math.random() < 0.5) {
            _results1.push(this.getCell(x, y).passable = false);
          } else {
            _results1.push(void 0);
          }
        }
        return _results1;
      }).call(this));
    }
    return _results;
  };

  Map.prototype.generateCrissCrossMap = function() {
    var corners, line_width;
    line_width = 1;
    this.eachCell(this.makeImpassable);
    corners = this.getCorners();
    this.forEachCellInLine(corners[0], corners[2], line_width, this.makePassable);
    return this.forEachCellInLine(corners[1], corners[3], line_width, this.makePassable);
  };

  Map.prototype.generateMazeMap = function() {
    var nodes;
    this.eachCell(this.makeImpassable);
    nodes = this.getMazeNodes();
    return this.connectMazeNodes(nodes, this.makePassable);
  };

  Map.prototype.eachCell = function(cb_func) {
    var x, y, _i, _ref, _results;
    _results = [];
    for (x = _i = 0, _ref = this.width; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
      _results.push((function() {
        var _j, _ref1, _results1;
        _results1 = [];
        for (y = _j = 0, _ref1 = this.height; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
          _results1.push(cb_func.call(this, this.getCell(x, y)));
        }
        return _results1;
      }).call(this));
    }
    return _results;
  };

  Map.prototype.getCorners = function() {
    return [this.getCell(0, 0), this.getCell(0, this.height - 1), this.getCell(this.width - 1, this.height - 1), this.getCell(this.width - 1, 0)];
  };

  Map.prototype.makeImpassable = function(cell) {
    return cell.passable = false;
  };

  Map.prototype.makePassable = function(cell) {
    return cell.passable = true;
  };

  Map.prototype.forEachCellInLine = function(from, to, width, cb_func) {
    var cursor, dx, dy, i, neigbours_by_x, new_x, new_y, results, steps_num, _i, _j, _ref, _ref1, _ref2, _ref3;
    results = [];
    dx = to.x - from.x;
    dy = to.y - from.y;
    neigbours_by_x = Math.abs(dx) < Math.abs(dy);
    steps_num = Math.abs(dx) + Math.abs(dy);
    i = 0;
    while (i <= steps_num) {
      cursor = {
        x: from.x + dx * i / steps_num,
        y: from.y + dy * i / steps_num
      };
      if (neigbours_by_x) {
        for (new_x = _i = _ref = cursor.x - width, _ref1 = cursor.x + width; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; new_x = _ref <= _ref1 ? ++_i : --_i) {
          if (new_x >= 0 && new_x < this.width) {
            results.push(this.getCell(new_x, cursor.y));
          }
        }
      } else {
        for (new_y = _j = _ref2 = cursor.y - width, _ref3 = cursor.y + width; _ref2 <= _ref3 ? _j <= _ref3 : _j >= _ref3; new_y = _ref2 <= _ref3 ? ++_j : --_j) {
          if (new_y >= 0 && new_y < this.height) {
            results.push(this.getCell(cursor.x, new_y));
          }
        }
      }
      i++;
    }
    for (i in results) {
      cb_func.call(this, results[i]);
    }
    return true;
  };

  Map.prototype.getMazeNodes = function() {
    var cell, cols_num, horizontal_shift, i, j, maze_nodes, rows_num, vertical_shift;
    rows_num = [];
    cols_num = [];
    vertical_shift = 1 - (this.width % 2);
    horizontal_shift = 1 - (this.height % 2);
    i = 0;
    while (i < this.width / 2) {
      if (i >= this.width / 4) {
        cols_num.push(i * 2 + vertical_shift);
      } else {
        cols_num.push(i * 2);
      }
      i++;
    }
    j = 0;
    while (j < this.height / 2) {
      if (j >= this.height / 4) {
        rows_num.push(j * 2 + horizontal_shift);
      } else {
        rows_num.push(j * 2);
      }
      j++;
    }
    maze_nodes = [];
    for (i in cols_num) {
      maze_nodes[i] = [];
      for (j in rows_num) {
        cell = this.getCell(cols_num[i], rows_num[j]);
        maze_nodes[i][j] = cell;
      }
    }
    return maze_nodes;
  };

  Map.prototype.connectMazeNodes = function(maze_nodes, cb_func) {
    var cell, cells, i, neighbours, new_cell, new_point, path, point, _results;
    path = [[0, 0]];
    cells = [];
    while (path.length > 0) {
      point = path[path.length - 1];
      cell = maze_nodes[point[0]][point[1]];
      cell.visited = true;
      cells.push(cell);
      neighbours = this.getUnvisitedNeighbourNodes(maze_nodes, point[0], point[1]);
      if (neighbours.length > 0) {
        new_point = neighbours[Math.floor(Math.random() * neighbours.length)];
        path.push(new_point);
        new_cell = maze_nodes[new_point[0]][new_point[1]];
        cells = cells.concat(this.getCellsBetween(cell, new_cell));
      } else {
        path.pop();
      }
    }
    _results = [];
    for (i in cells) {
      _results.push(cb_func.call(this, cells[i]));
    }
    return _results;
  };

  Map.prototype.getCellsBetween = function(from, to) {
    var result, x, y, _i, _j, _ref, _ref1, _ref2, _ref3;
    result = [];
    if (from.x === to.x) {
      for (y = _i = _ref = from.y, _ref1 = to.y; _ref <= _ref1 ? _i < _ref1 : _i > _ref1; y = _ref <= _ref1 ? ++_i : --_i) {
        result.push(this.getCell(from.x, y));
      }
    } else if (from.y === to.y) {
      for (x = _j = _ref2 = from.x, _ref3 = to.x; _ref2 <= _ref3 ? _j < _ref3 : _j > _ref3; x = _ref2 <= _ref3 ? ++_j : --_j) {
        result.push(this.getCell(x, from.y));
      }
    } else {

    }
    return result.slice(1);
  };

  Map.prototype.getUnvisitedNeighbourNodes = function(maze_nodes, x, y) {
    var max_x, max_y, neighbours;
    max_x = (this.width / 2) - 1;
    max_y = (this.height / 2) - 1;
    neighbours = [];
    if (x > 0 && !maze_nodes[x - 1][y].visited) {
      neighbours.push([x - 1, y]);
    }
    if (x < max_x && !maze_nodes[x + 1][y].visited) {
      neighbours.push([x + 1, y]);
    }
    if (y > 0 && !maze_nodes[x][y - 1].visited) {
      neighbours.push([x, y - 1]);
    }
    if (y < max_y && !maze_nodes[x][y + 1].visited) {
      neighbours.push([x, y + 1]);
    }
    return neighbours;
  };

  return Map;

})();
