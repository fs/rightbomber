// Generated by CoffeeScript 1.3.3
var SquaredObject,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

SquaredObject = (function(_super) {

  __extends(SquaredObject, _super);

  SquaredObject.prototype.map = null;

  SquaredObject.prototype.size = 1;

  SquaredObject.prototype.moved = false;

  SquaredObject.prototype.velocity = 0;

  SquaredObject.prototype.epsilon = 0.001;

  function SquaredObject(map) {
    this.map = map;
    this.map.objects.push(this);
    this.direction = new Direction();
    this.setSize(this.size);
  }

  SquaredObject.prototype.setSize = function(newSize) {
    this.size = newSize;
    return SquaredObject.__super__.setSize.call(this, newSize);
  };

  SquaredObject.prototype.olderBy = function(timeDelta) {
    var distance, distanceToGo;
    distanceToGo = distance = this.velocity * timeDelta;
    if (distanceToGo > 0) {
      distanceToGo = this.sprint(distanceToGo);
    }
    if (distanceToGo > 0) {
      distanceToGo = this.comeCloser(distanceToGo);
    }
    if (distanceToGo > 0) {
      distanceToGo = this.cutCorners(distanceToGo);
    }
    return distanceToGo < distance;
  };

  SquaredObject.prototype.sprint = function(distance) {
    var step;
    step = this.size;
    while (distance > step) {
      if (this.move(step)) {
        distance -= step;
      } else {
        break;
      }
    }
    return distance;
  };

  SquaredObject.prototype.comeCloser = function(distance) {
    var step;
    distance = Math.min(this.size, distance);
    step = distance;
    while (Math.min(step, distance) > this.epsilon) {
      if (this.move(step)) {
        distance -= step;
      } else {
        step /= 2;
      }
    }
    return distance;
  };

  SquaredObject.prototype.cutCorners = function(distance) {
    var area, dx, dy, impactArea, leftArea, rightArea;
    dx = this.direction.dx(distance);
    dy = this.direction.dy(distance);
    this.moveBy(dx, dy);
    this.direction.save();
    impactArea = this.blockedArea();
    this.direction.restore().rotateLeft();
    leftArea = this.blockedAreaAt(distance);
    this.direction.restore().rotateRight();
    rightArea = this.blockedAreaAt(distance);
    this.moveBy(-dx, -dy);
    if (leftArea > rightArea) {
      area = rightArea;
      this.direction.restore().rotateRight();
    } else {
      area = leftArea;
      this.direction.restore().rotateLeft();
    }
    if (area < Math.min(impactArea, this.size * distance)) {
      if (this.move(distance)) {
        distance = 0;
      }
    }
    this.direction.restore();
    return distance;
  };

  SquaredObject.prototype.move = function(distance) {
    var dx, dy, movable;
    dx = this.direction.dx(distance);
    dy = this.direction.dy(distance);
    this.moveBy(dx, dy);
    if (!(movable = this.isMovable())) {
      this.moveBy(-dx, -dy);
    }
    return movable;
  };

  SquaredObject.prototype.blockedAreaAt = function(distance) {
    var area, dx, dy;
    dx = this.direction.dx(distance);
    dy = this.direction.dy(distance);
    this.moveBy(dx, dy);
    area = this.blockedArea();
    this.moveBy(-dx, -dy);
    return area;
  };

  SquaredObject.prototype.intersectsWith = function(object) {
    if (object instanceof Cell) {
      return !object.passable && SquaredObject.__super__.intersectsWith.call(this, object);
    } else {
      return this !== object && SquaredObject.__super__.intersectsWith.call(this, object);
    }
  };

  SquaredObject.prototype.isMovable = function() {
    var object, _i, _len, _ref;
    if (!this.map.contains(this)) {
      return false;
    }
    _ref = this.map.objects;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      object = _ref[_i];
      if (this.intersectsWith(object)) {
        return false;
      }
    }
    return true;
  };

  SquaredObject.prototype.blockedArea = function() {
    var area, object, _i, _len, _ref;
    if (!this.map.contains(this)) {
      return this.size * this.size;
    }
    area = 0;
    _ref = this.map.objects;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      object = _ref[_i];
      area += this.intersectionArea(object);
    }
    return area;
  };

  return SquaredObject;

})(Rect);
