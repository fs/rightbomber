// Generated by CoffeeScript 1.3.3
var SquaredObject,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

SquaredObject = (function(_super) {

  __extends(SquaredObject, _super);

  SquaredObject.prototype.map = null;

  SquaredObject.prototype.size = 1;

  SquaredObject.prototype.moved = false;

  SquaredObject.prototype.velocity = 0;

  SquaredObject.prototype.direction = 0;

  SquaredObject.prototype.epsilon = 0.001;

  function SquaredObject(map) {
    this.map = map;
    this.map.objects.push(this);
    this.setSize(this.size);
  }

  SquaredObject.prototype.setSize = function(newSize) {
    this.size = newSize;
    return SquaredObject.__super__.setSize.call(this, newSize);
  };

  SquaredObject.prototype.olderBy = function(timeDelta) {
    var distance, distanceToGo;
    distance = distanceToGo = this.velocity * timeDelta;
    if (distance > 0) {
      distance = this.sprint(distance);
    }
    if (distance > 0) {
      distance = this.comeCloser(distance);
    }
    if (distance > 0) {
      distance = this.cutCorners(distance);
    }
    return distance < distanceToGo;
  };

  SquaredObject.prototype.sprint = function(distance) {
    var step;
    step = this.size;
    while (distance > step) {
      if (this.move(step, this.direction)) {
        distance -= step;
      } else {
        break;
      }
    }
    return distance;
  };

  SquaredObject.prototype.comeCloser = function(distance) {
    var step;
    distance = Math.min(this.size, distance);
    step = distance;
    while (Math.min(step, distance) > this.epsilon) {
      if (this.move(step, this.direction)) {
        distance -= step;
      } else {
        step /= 2;
      }
    }
    return distance;
  };

  SquaredObject.prototype.cutCorners = function(distance) {
    var direction, moved;
    direction = this.rotateLeft(this.direction);
    moved = this.move(distance, direction);
    if (!moved) {
      direction = this.rotateRight(this.direction);
      moved = this.move(distance, direction);
    }
    if (moved) {
      return 0;
    } else {
      return distance;
    }
  };

  SquaredObject.prototype.move = function(distance, direction) {
    var dx, dy, movable;
    dx = this.dx(distance, direction);
    dy = this.dy(distance, direction);
    this.moveBy(dx, dy);
    if (!(movable = this.isMovable())) {
      this.moveBy(-dx, -dy);
    }
    return movable;
  };

  SquaredObject.prototype.dx = function(distance, direction) {
    switch (direction) {
      case 0:
        return distance;
      case 2:
        return -distance;
      default:
        return 0;
    }
  };

  SquaredObject.prototype.dy = function(distance, direction) {
    switch (direction) {
      case 1:
        return distance;
      case 3:
        return -distance;
      default:
        return 0;
    }
  };

  SquaredObject.prototype.rotateLeft = function(direction) {
    return (direction + 5) % 4;
  };

  SquaredObject.prototype.rotateRight = function(direction) {
    return (direction + 7) % 4;
  };

  SquaredObject.prototype.isMovable = function() {
    var cell, cells, object, _i, _j, _len, _len1, _ref;
    if (!this.map.contains(this)) {
      return false;
    }
    cells = [this.map.getCell(this.left, this.top), this.map.getCell(this.left, this.bottom), this.map.getCell(this.right, this.top), this.map.getCell(this.right, this.bottom)];
    for (_i = 0, _len = cells.length; _i < _len; _i++) {
      cell = cells[_i];
      if (!cell.passable) {
        return false;
      }
      _ref = cell.objects;
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        object = _ref[_j];
        if (this !== object && this.intersectsWith(object)) {
          return false;
        }
      }
    }
    return true;
  };

  return SquaredObject;

})(Rect);
